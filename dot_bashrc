# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

##########################
# Various shell settings #
##########################

HISTCONTROL=ignoreboth # no duplicates or lines start with space
HISTSIZE=10000
HISTFILESIZE=2000
shopt -s histappend # append to the history file, don't overwrite it
shopt -s checkwinsize
shopt -s direxpand #turn on shell variable dir expansion
ulimit -c 41943040

#########################
# Fancy prompt handling #
#########################

# This function outputs the path for use in the command prompt
function showPath()
{
   # If we are in a git repo, then this command shows the path relative to the
   # git base dir, not the full path
   promptPathToShow=$(git rev-parse --show-prefix 2>/dev/null)
   rc=$?
   if [ $rc -ne 0 ] ; then
      # If the git command failed it means we are not in a git repo. In that
      # case we do not show the git repo and just show the full path (with ~
      # instead of the absolute home path)
      promptPathToShow="${PWD}"
      echo ${promptPathToShow} | sed "s|${HOME}|\~|g"
   else
      echo ${promptPathToShow}
   fi
}

# This functions outputs the git repo current branch if you happen to be in one
function showBranch()
{
   gitBranch=$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/*//' -e 's/^ *//g')
   # only show stuff if git command worked. If it failed then we are not in a
   # git repo.
   if [ "x${gitBranch}" != "x" ] ; then
      echo ${gitBranch}
   else
      echo "git:none"
   fi
}

# This function shows the git repo base dir if you are in a git branch
function showBase()
{
   baseDir=$(git rev-parse --show-toplevel 2>/dev/null)
   rc=$?
   # only show stuff if git command worked. IF it failed then we are not in a
   # git repo.
   # Funny exception: If you are in the .git directory itself, then the above
   # git command is successful, however it returns empty string. In that case
   # we'll leave the baseDir empty, although the git repo will still be shown.
   if [ $rc -eq 0 -a "x${baseDir}" != "x" ] ; then
      baseName=$(basename ${baseDir})
      echo "${baseName}/"
   fi
}

# Now here comes the magic using PS1 variable
export PS1="\[\e[1;36m\][\[\e[0;32m\]\u\[\e[0;36m\]@\[\e[0;32m\]\h\[\e[1;36m\]]\[\e[0m\] \[\e[1;36m\][\[\e[0;95m\]\$(showBranch)\[\e[1;36m\]] \[\e[1;33m\]\$(showBase)\[\e[0;33m\]\$(showPath)==>\[\e[0m\] "

#############################################
# Source aliases and custom shell functions #
#############################################

if [ -f ~/.aliases ]; then
    . ~/.aliases
fi

if [ -f ~/.bashfuncs ] ; then
    . ~/.bashfuncs
fi

####################
# Various env vars #
####################

export EDITOR="/usr/bin/emacs"
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

#######################################
# Other junk from the original bashrc #
#######################################

# make less more friendly] for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# enable dir colours
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
fi

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi
